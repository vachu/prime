/*
A much simplified package that provides APIs for listing and testing primes.
Internally generates first 1 million unsigned primes that are used for all the
operations, at startup / init.

NOTE: Number '1' is not considered a prime by this package.  Negative Numbers /
Primes are not considered either.
*/
package primelib

import "math"

const maxPrimeCount = 1000 * 1000

var arrPrimes [maxPrimeCount]uint32

func init() {
	arrPrimes[0] = 2
	primeCount := 1
	for number := uint32(3); primeCount < maxPrimeCount; number += 2 {
		if isPrime(number) {
			arrPrimes[primeCount] = number
			primeCount++
		}
	}
}

func isPrime(number uint32) bool {
	isComposite := false
	stopLimit := uint32(math.Trunc(math.Sqrt(float64(number))))
	for i := 0; !isComposite && arrPrimes[i] <= stopLimit; i++ {
		isComposite = (number%arrPrimes[i] == 0)
	}
	return !isComposite
}

// List first 'cnt' 32-bit primes onto the supplied output channel 'out'
//
// NOTE/WARNING: Always call this method concurrently egs. 'go ListPrimes(...)'
func ListPrimes(out chan uint32, cnt uint32) {
	number := arrPrimes[maxPrimeCount-1] + 2
	for i := uint32(0); i < cnt && i < maxPrimeCount; i++ {
		out <- arrPrimes[i]
	}
	for i := uint32(maxPrimeCount); i < cnt && number < math.MaxUint32; number += 2 {
		if isPrime(number) {
			out <- number
			i++
		}
	}
	close(out)
}

// List all 32-bit primes between >= 'from' AND <= 'to' onto the
// supplied output channel 'out'
//
// NOTE/WARNING: Always call this method concurrently egs. 'go ListPrimesBetween(...)'
func ListPrimesBetween(out chan uint32, from, to uint32) {
	if to > 0 && from <= to {
		number := from
		if number <= arrPrimes[maxPrimeCount-1] {
			// print from the internal prime array
			for i := 0; i < maxPrimeCount; i++ {
				if arrPrimes[i] >= from && arrPrimes[i] <= to {
					out <- arrPrimes[i]
				}
			}
			number = arrPrimes[maxPrimeCount-1] + 2
		} else if number%2 == 0 {
			number++
		}
		for ; number >= from && number <= to; number += 2 {
			if isPrime(number) {
				out <- number
			}
		}
	}
	close(out)
}

// Returns the smallest / first prime factor for the supplied 'number'.
// If 'MaxPrime' is the largest internal prime generated by this package and
// if 'number' > 'MaxPrime' ^ 2, then the method returns '0' (ZERO)
func GetFirstPrimeFactor(number uint64) uint64 {
	maxPrime := uint64(arrPrimes[maxPrimeCount-1])
	if number > maxPrime*maxPrime {
		return 0 // cannot reliably test
	}

	stopLimit := uint32(math.Trunc(math.Sqrt(float64(number))))
	for i := 0; i < maxPrimeCount && arrPrimes[i] <= stopLimit; i++ {
		if number%uint64(arrPrimes[i]) == 0 {
			return uint64(arrPrimes[i])
		}
	}
	return number // number is prime
}
